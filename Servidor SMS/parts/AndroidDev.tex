\chapter{El desarrollo en Android}
\label{cpt:android.dev}

En este cap\'itulo se describen las distintas partes que componen una aplicaci\'on Android y como la plataforma se encuentra estructurada para poder dar soporte y manejo a las mismas.

\section{La \ac{DVM}}
\label{sec:dvm}

Dalvik es la m\'aquina virtual que utiliza la plataforma para dispositivos m\'oviles Android. El dise\~no fue realizado por Dan Bornstein con contribuciones de otros ingenieros de Google.

Dalvik est\'a optimizada para requerir poca memoria y est\'a diseñada para permitir la ejecuci\'on de varias instancias de la m\'aquina virtual simult\'aneamente, delegando en el sistema operativo subyacente el soporte de aislamiento de procesos, gesti\'on de memoria e hilos.

A menudo, Dalvik es nombrada como una m\'aquina virtual Java, pero esto no es estrictamente correcto, ya que el bytecode con el que opera no es Java bytecode. Sin embargo, la herramienta dx incluida en el \ac{SDK} de Android permite transformar los archivos \texttt{.class} de Java compilados por un compilador Java al formato de archivos \texttt{.dex}.

El nombre de Dalvik fue elegido por Bornstein en honor a Dalvík, un pueblo de Islandia donde vivieron antepasados suyos.~\cite{wiki.dvm}

\section{La arquitectura Android}
\label{sec:arq}

La arquitectura del sistema operativo esta compuesto por las siguientes caracter\'isticas (ver figura \ref{fig:android.architecture}):

\figuraot{La arquitectura Android}{fig:android.architecture}{width=\textwidth}{Android-system-architecture}{!h}

\begin{itemize}
\item Aplicaciones (escritas en Java, ejecutadas en Dalvik).
\item Librer\'ias y servicios del framework (escritas en su mayoria en Java).
\subitem Las aplicaciones y la mayor parte del c\'odigo del framework ejecutadas en la m\'aquina virtual. 
\item Librerias nativas, daemons y servicios (escritos en C o C++).
\item El kernel de linux, que incluye drivers para:
\subitem hardware
\subitem redes
\subitem sistema de acceso a archivos
\subitem \ac{IPC}
\end{itemize}

\section{Partes que componen un proyecto de desarrollo Android}
\label{sec:dev.components}

En esta secci\'on se presentan las distintas clases, vistas y recursos. Como interactuan cada uno de ellos y cual es el prop\'osito de cada uno.

\subsection{Las activities}
\label{subsec:dev.activities}

Una activity conforma las siguientes caracter\'isticas:

\begin{itemize}
\item Consiste en una pantalla dentro de una aplicaci\'on.
\item Una aplicaci\'on puede contener una o m\'as Activities.
\item Pueden ser invocadas desde otras aplicaciones.
\item Cada activity es independiente de las dem\'as.
\item Todas las Activities extienden de la clase Activity.
\item Cada Activity tiene una ventana en la cual mostrarse.
\item Normalmente ocupa toda la pantalla.
\item Puede utilizar ventanas adicionales como dialogs.
\item Se muestra utilizando un \'arbol de vistas que extienden de la clase view.
\item El ra\'iz del \'arbol se define llamando al m\'etodo \texttt{setContentView}.
\end{itemize}

\subsection{El ciclo de vida de una activity}
\label{subsec:dev.activity.lifecycle}

Una activity tiene tres estados principales:

\begin{numerate}
\item Active, actualmente en pantalla con foco.
\item Paused, perdi\'o foco, contin\'ua parcialmente visible.
\item Stopped, fue tapado por otra Activity.
\end{numerate}

Las transiciones de estado son notificadas al activity por una serie de m\'etodos protegidos. Se deber\'a mantener una llamada al m\'etodo original en la clase padre al sobreescribir cualquiera de estos m\'etodos.

Los siete m\'etodos del ciclo de vida (figura \ref{fig:android.activity.lifecycle}) pueden ser utilizados para monitorear los siguientes subciclos.

\begin{itemize}
\item Tiempo de vida, usado para liberar recursos en el \texttt{onDestroy} que fueron creados en el \texttt{onCreate}.
\item Visibilidad, para mantener recursos que afecten la UI.
\item Primer plano, para mantener la interactividad con el usuario.
\end{itemize}

\figuraot{Ciclo de vida de una activity}{fig:android.activity.lifecycle}{width=\textwidth}{activity_lifecycle}{!h}

\subsection{El back stack de activities}
\label{subsec:dev.activity.stack}

Las activities son administradas mediante una pila denominada back stack en el orden en el cual cada una de estas activities se va creando.

Cuando una activity en pantalla inicia otra, la nueva activity se coloca al tope del back stack y toma el foco de la pantalla. La actividad anterior se mantiene en el back stack, pero se detiene. Cuando se ingresa al estado de stop, el sistema retiene el estado actual de su \ac{UI}.

En el momento en el que el usuario presiona el bot\'on de retroceso del dispositivo, la actividad actual se destruye y la anterior a esta ejecuta el m\'etodo \texttt{resume} para volver recuperar su estado y pueda ser visualizado en pantalla.

De ninguna forma las activities pueden cambiar su posici\'on dentro del back stack, ya que justamente se opera como una pila de \'ultimo en entrar, primero en salir. La figura \ref{fig:android.activity.lifecycle} visualiza el comportamiento en el tiempo mostrando el progreso entre las distintas activities y como el back stack se encuentra formado en las distintas etapas.

\figuraot{Diagrama del back stack de activities}{fig:android.stackActivities}{width=\textwidth}{diagram_backstack}{!h}

\subsection{Los Intents}
\label{subsec:dev.intents}

Un intent es una descripci\'on abstracta de una operaci\'on a ser ejecutada. Puede ser utilizado con el me\'todo \texttt{startActivity} para transferir informaci\'on entre distintas activities, como una de las funciones m\'as importantes, entre otras m\'as.

Por medio de un intent, se hace disponible realizar late binding en tiempo de ejecuci\'on entre el c\'odigo en diferentes aplicaciones. Basicamente consiste en una estructura de datos pasiva conteniendo una descripci\'on abstracta de una acci\'on a ser realizada.

Un intent puede referenciar un componente, y si la referencia no es expl\'icita Android buscar\'a el componente que mejor responda.

\subsection{El Manifest}
\label{subsec:dev.manifest}

El manifest consiste en un archivo en formato \texttt{.xml} donde cada aplicaci\'on describe y declara todos sus componentes, sus permisos que requerira para acceder a partes protegidas de la \ac{API} y su interacci\'on con otras aplicaciones, su nivel m\'inimo de \ac{API} Android requerido y todas las librer\'ias a las que la aplicaci\'on hace uso.

Cada aplicaci\'on tiene su manifest que se incluir\'a en el archivo \texttt{.apk}.

\subsection{Los layouts}
\label{subsec:dev.layouts}

El layout define la distribuci\'on de las vistas y contenedores, como la \ac{UI} de una activity on una aplicaci\'on tipo widget.

Los layouts pueden definirse:

\begin{itemize}
\item en el formato \texttt{.xml}: brindando un vocabulario que corresponde a las clases y subclases de View, aquellos los cuales est\'an definidos para layouts y widgets.
\item instanciando los elementos en tiempo de ejecuci\'on: la aplicaci\'on puede crear objetos del tipo View y ViewGroup (y manipular sus propiedades) programaticamente.
\end{itemize}

Cada tipo de layout se encuentra ubicado en una jerarqu\'ia de vistas (views) (figura \ref{}) con par\'ametros de layout asociados a cada una de estas vistas. 

\figuraot{Jerarqu\'ia de vistas y layouts}{fig:android.layouts}{width=\textwidth}{layoutparams}{!h}

\subsection{Los eventos de \ac{UI}}
\label{subsec:dev.ui.events}

MAURIX!!!

View permite registrar distintos listeners para los siguientes  eventos.

onClick()
onLongCick()
onFocusChange()
onKey()
onTouch()
onCreateContextMenu()

\subsection{El Style}
\label{subsec:dev.style}

Es una colecci\'on de propiedades que especifican el formato de una vista. Los estilos se definen en XML.

\subsection{El Theme}
\label{subsec:dev.theme}

Cuando un Style es aplicado a un Activity o Aplication se lo denomina Theme.

Todas las vistas del Activity o Application tendr\'an el Style aplicado.

\subsection{El AdapterView}
\label{subsec:dev.adapterView}

Es una subclase de ViewGroup.

Sus vistas hijas son definidas por un Adapter.

Se utiliza para mostrar datos almacenados.

Algunos AdapterView son:
Gallery
ListView
Spinner

El adapter es una clase utilizada por un AdapterView para obtener datos y  construir las vistas hijas.

\subsection{Los men\'ues}
\label{subsec:dev.menus}

Option menu, es el men\'u principal de un activity, se muestra  al presionar el boton men\'u.

Context Menu, es un men\'u flotante que se muestra al hacer  “long press” sobre una vista.

Submenu, es un men\'u flotante de items que el usuario abre al  seleccionar un item de men\'u.

\subsection{Los Dialogs}
\label{subsec:dev.dialogs}

El dialog toma el primer plano quitandole el foco al Activity  que le dio origen.

Para crear un dialog se extiende de la clase Dialog.

El API de Android provee los siguientes tipos de dialogs:

AlertDialog
ProgressDialog
DatePickerDialog
TimePickerDialog

\subsection{Los Resources}
\label{subsec:dev.resources}

A cada resource se le asigna un ID.

Los IDs est\'an definidos en la clase R del proyecto.

La clase R es generada durante la compilaci\'on.

R tiene una clase est\'atica para cada tipo de resource.

Por cada resource hay un integer est\'atico.

Los resources pueden ser accedidos desde el c\'odigo o desde XML.

\subsection{El ASyncTask}
\label{subsec:dev.asynctask}

El método doInBackground(…) se ejecuta en un thread  aparte.

Los métodos onPreExecute(…)  y onPostExecute(…) se  ejecutan en el thread de UI. 

\subsection{El Content Provider}
\label{subsec:dev.contentProvider}

An SQLite database is private to the application which creates it. If you want to share data with other applications you can use a ContentProvider.

A ContentProvider allows applications to access data. In most cases this data is stored in an SQlite database.
A ContentProvider can be used internally in an application to access data. If the data should be shared with another application a ContentProvider allows this.
The access to a ContentProvider is done via an URI. The basis for the URI is defined in the declaration of the ContentProvider in the AndroidManifest.xml file via the android:authorities attribute.
Many Android datasources, e.g. the contacts, are accessible via ContentProviders. Typically the implementing classes for a ContentProviders provide public constants for the URIs

SQlite stores the whole database in a file. If you have access to this file, you can work directly with the data base. Accessing the SQlite database file only works in the emulator or on a rooted device.

A standard Android device will not grant read-access to the database file.

Content providers can be used from other processes and are required by some mechanisms on Android like the global search. There are also some classes available that help you deal with content providers that save you some of the hassle of manging memory.

   * Other apps will be able to access your data.

   * You can wrap and abstract a lot of the query logic in your content provider, and limit access.

   * You will be able to lean on the system to allow for things like managed queries.

\section{Los Servicios}
\label{sec:services}

Un servicio es un componente de la aplicaci\'on que puede realizar operaciones long-running o de larga corrida en el background o en segundo plano y no provee de una \ac{UI}.

Otro componente de la aplicaci\'on puede iniciar un servicio y este continuar\'a corriendo en segundo plano a\'un si el usuario cambia a otra aplicaci\'on. Adicionalmente, un componente puede unirse a un servicio para interactuar con este y tambi\'en para realizar \ac{IPC}. Por ejemplo, un servicio podr\'ia manejar transacciones de red, reproducir m\'usica, ejecutar acciones de entrada y salida sobre archivos (file I/O), o interactuar con un content provider, todo desde un segundo plano que resulta invisible al usuario.

Hay que considerar que un servicio corre en el thread principal del proceso que lo contiene. El servicio no crea su propio thread y no corre en procesos separados, a menos que se lo especifique.

\section{Los secretos de performance}
\label{sec:performance.secrets}

http://developer.android.com/training/articles/perf-tips.html

\begin{enumerate}

\item Evitar crear objetos innecesarios: La creaci\'on de objetos siempre tiene un costo. Un garbage collector generacional con pools de asignaci\'on por thread para objectos temporarios puede hacer la asignaci\'on de objetos un poco m\'as eficiente, pero la asignaci\'on de memoria es siempre m\'as costosa que no asignar memoria para los objetos.

\item Es preferible un est\'atico sobre un virtual: Si no es necesario acceder a las variables de un objeto, es recomendable hacer los m\'etodos est\'ticos. Las llamadas tendr\'an un aumento de velocidad entre 15\%-20\%. Es una buena pr\'actica tambi\'en, porque se podr\'ia dar la informaci\'on desde la firma del m\'etodo que al llamar al m\'etodo, este no pueda alterar el estado del objeto.

\item Usar static final para constantes: Es una buena pr\'actica declarar las constantes como static final cuando sea posible, ya que de esta manera se evita el uso de un m\'etodo de inicializaci\'on de clase. 

\item Evitar getters/setters internos: Llamadas a m\'etodos virtuales son costosas, mucho m\'as que la b\'usqueda de variables instanciadas. Es razonable seguir pr\'acticas de programaci\'on orientada a objetos y tener getters y setters en una interfaz p\'ublica, pero dentro de una clase uno deber\'ia siempre acceder a las variables directamente.

\item Usar la nueva sintaxis del ciclo For: La nueva sintaxis del ciclo For, conocida tambi\'en como el ciclo "for-each", puede ser utilizada para collections que implementen la interfaz Iterable y para arrays. Con las collections, un iterator es asignado para hacer llamadas a la interfaz de hasNext() y next(). Con un ArrayList, un ciclo con contador es cerca de 3 veces m\'as r\'apido (con o sin \ac{JIT}), pero para otras collections el nuevo ciclo For ser\'a exactamente equivalente al de un iterator explicito.

\item Evitar usar puntos flotantes (floating-points): Los puntos flotantes son 2 veces m\'as lentos que los integers o enteros en los dispositivos Android. En t\'erminos de velocidad, no hay diferencia entre el float y el double en los hardware modernos. En tama\~no, double es 2 veces mas grande. Con M\'aquinas de escritorio, asumiendo que el espacio no es un problema, ser\'ia preferible double antes que float. 

\item Saber usar las librerias: Adem\'as de conocer las razones de utilizar una librer\'ia que ya se encuentre disponible antes que armar una propia, hay que tener en cuenta que el sistema ofrece la libertad de poder reemplazar las llamadas a m\'etodos de librer\'ias con otras que contengan c\'odigo assembler, las cuales podrian ser mejores en comparaci\'on con el mejor c\'odigo que el \ac{JIT} pueda producir para su equivalente en Java.

\end{enumerate}

\subsection{Mitos de performance}
\label{subsec:dev.perf.myths}

En dispositivos sin \ac{JIT}, es cierto que invocar m\'etodos a trav\'es de una variable con un tipo exacto que a trav\'es de una interfaz es sutilmente m\'as eficiente (por ejemplo, es mejor invocar m\'etodos en un HashMap Map que en un Map map, a\'un cuando en ambos casos el map fuera un HashMap). 

En dispositivos sin \ac{JIT}, realizar caching para los accesos a las variables de objetos logra una mejora del 20\% que repetidamente acceder a la misma variable. Con un \ac{JIT}, el acceso a variables cuesta lo mismo que a un acceso a variables de un objeto en forma local, por lo tanto, no es una optimizaci\'on requerida a menos que uno sienta que esto facilita la lectura del c\'odigo (ocurre lo mismo para los tipos final, static y static final).

\subsection{Siempre medir}
\label{subsec:dev.perf.measure.always}

Antes de comenzar a optimizar, hay que asegurarse que uno tenga un problema que necesite resolver. Para esto, es importante medir con detalle la performance existente, porque de otra manera, no se podr\'a medir el beneficio de la implementaci\'on de alguna alternativa de mejora.

Se recomienda utilizar Caliper para correr los microbenchmarks creados por uno mismo. El Caliper es un framework de microbenchmarking para Java.

\section{La interacción con servicios remotos}
\label{sec:remote.services}

El parser de JSON que provee Android es poco performante.

JSON con GSON (mejor performance que el parser provisto  por Android).

\section{El \ac{DDMS}}
\label{sec:ddms}

Perspectiva de Eclipse.

Debugging.

Permite ver memoria y file system.

Profiling.

\section{El LogCat}
\label{sec:logcat}

El m\'etodo Log.e() se utiliza para registrar errores.
El m\'etodo Log.w() se utiliza para registrar precauciones o warnings.
El m\'etodo Log.i() se utiliza para registrar mensajes de informaci\'on.
El m\'etodo Log.d() se utiliza para registrar mensajes del tipo debug.
El m\'etodo Log.v() se utiliza para registrar mensajes verbales.
El m\'etodo Log.wtf() se utiliza para registrar errores muy graves que nunca deberian ocurrir (What a Terrible Failure).

La salida b\'asica del LogCat incluye informaci\'on de diferentes fuentes. Para su uso en actividades de debug, puede ser muy \'util filtrar la salida del LogCat de acuerdo a diferentes etiquetas o tags para la aplicaci\'on espec\'ifica que se quiera analizar. De esta manera, uno puede enfocar en los logs de la propia aplicaci\'on y evitar recibir informaci\'on de otras fuentes o partes que para el caso a analizar sean de poco inter\'es.
